Java基础
一、常用的集合有哪些，谈谈对它们的理解?
	Conllection接口：单例集合 有两个子接口
		1.List接口：
		  LinkedList：基于链表实现，每一个元素储存本身内存地址的同时还存储下一个元素的地址，链表增删块，查找慢。
		  ArrayList:基于数组，每次增删都要创建新的数组，但数组有索引。数组增删慢，查找快。
		  Vector:基于数组，线程安全，效率低。
		2.Set接口：
		HashSet：存储的元素无序，不可重复，底层是哈希表。
		LinkedHashSet:存储的元素有序，不可重复，底层是哈希表和链表的结合。
	Map接口：双列集合
		HashMap：非线程安全，高效 支持null；
		LinkedHashMap:是hashMap的一个子类，保存了记录的插入顺序
		HashTable：线程安全，低效，不支持null；
		TreeMap：能够把他保存的记录根据键排序，默认是键值的升序排序。
二、IO流
	字节流和字符流的区别？
	1.字节流读取的时候，读取一个字节就返回一个字节；字符流使用了字节流读到一个或多个字节(中文对应的字节数是两个，在UTF-8码表中时三个字节)时。
	先去查指定的编码表，将查到的字符返回。
	2.字节流可以处理所有类型的数据如：图片 avi视频 mp3等文件，而字符流只能处理字符数据，只要是纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。
	还有一些特别的流类型
	装换流：装换流只有字节流转换为字符流，因为字符流使用起来更加方便，我们只会想更方便使用的方向转化  如InputStreamReader与OutputStreamWriter。
	缓冲流：有关键字Buffered，也是一种处理流，为其包装的流增加了缓存功能，提高了输入输出的效率，增加缓冲功能后需要使用fiush()才能将缓冲区中内容
			写入到实际的物理节点。但是在现在的Java中，只需要记得关闭输出流（调用close()方法），就会自动执行输出流的flush()方法，可以将缓冲区中的东西写入。
	对象流：有关键字Object，主要用于将目标对象保存到磁盘中或允许在网络中直接传输对象时使用（对象序列化）。
三、线程和进程的区别？
	线程：是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。
	进程：具有一定独立功能的程序关于莫个数据集合上的一次运动活动，是操作系统进行资源分配和调度的一个独立单位。
	特点：线程的划分尺度小于进程，这使多线程程序拥有高并发。
		  进程在运行时各自内存单元相互独立，线程之间内存共享，这使多线程编程可以拥有更好的性能和用户体验。
	注意：多线程编程对于其他程序是不太有好的，占据大量的cpu资源。
四、启动一个线程是调用run()方法还是start()方法？
	  启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行的状态，这意味着他可以由JVM调用并执行，这不意味着线程就会立刻运行。
	  run()方法是线程启动后要进行回调（callback）的方法。
五、编写多线程程序的几种实现方式（创建多线程的方式）？
	1):通过继承Thread类
	2):通过实现Runnable接口(推荐使用，因为Java中是单继承，一个类只有一个父类，
							若继承了Thread类，就无法在继承其他的类，显然实现Runnable接口更为灵活)。
	3):通过实现Callable接口
六、解决多线程安全问题的几种方式？
	(1)同步代码块：在代码块声明上  加上 synchronize
				synchronize(锁对象){
					可能会产生线程安全的代码
				}
		同步代码块中的锁对象可以是任何的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。
	(2)同步方法：在方法声明上加上synchronize
				public synchronize void method(){
					可能会产生线程安全的代码
				}
		同步方法中的锁对象是this
		静态同步方法：在方法声明上加上 static synchronize 
		静态同步方法中的锁对象是   类名. class
	(3)同步锁：Lock 接口提供了与synchronize关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。
七、sleep()和wait()有什么区别？
	1.每个对象都有一个锁来控制同步访问，synchronize关键字可以和对象的锁交互，来实现同步方法或同步块。
	sleep()方法正在执行的线程主动让出cpu(然后CPU就可以去执行其他任务)，在sleep指定时间后cpu再回到该线程继续往下执行（
	  注意：sleep方法只让出了cpu，而并不会释放同步资源锁）。
	wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法。
		  之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行(注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务
		  就是说notify只是让之前调用wait的线程有权利重新参与线程的调度)；
	2.sleep()方法可以在任何地方使用；wait()方法	，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁到时间会自动恢复，wait()是object的方法，
		  调用会放弃对象锁，进入等待队列，待调用notify()和notifyAll()唤醒指定的线程或者所有的线程，才会进入锁池，再次获得对象锁才会进入运行状态。
八、线程的五种状态和转换方式？
	线程从创建、运行到结束总是处于下面五个状态之一：新建状态  就绪状态  阻塞状态 以及死亡状态
	   1)新建状态
	   当用new操作符创建一个线程的时候，此时程序还没有开始运行线程中的代码。
	   2)就绪状态
	   一个新创建的线程并不会自动开始运行，要执行线程，必修调用线程的start()方法。当线程对象对象调用了start()方法即启动了线程，start()方法创建线程
	   运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态，处于就绪状态的线程并不一定立即运行run()方法，线程还必须同
	   其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因
	   此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。
	   3)运行状态（runring）
	   当线程获得cpu时间后，他才能进入运行状态，真正开始执行run()方法。
	   4)阻塞状态(blocker)
	   线程运行过程中，可能由于各种原因进入阻塞状态；
	   ①线程通过调用sleep方法进入睡眠状态；
	   ②线程调用一个在i/o上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到他的调用者；
	   ③线程试图得到一个锁，而该锁正被其他的线程持有；
	   ④线程在等待摸个触发条件；
	   所谓阻塞状态是在运行的线程没有运行结束，暂时让出cpu，这时其他处于就绪状态的线程就可以获得cpu时间，进入运行状态。
	   5)死亡状态
	   ①run方法正常退出而自然死亡；
	   ②一个未捕获的异常终止了run方法而使线程猝死；
	   为了确定线程在当前是否存活着(就是要么是可运行的，要么是被阻塞了)，需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new
	   状态且不是可运行的。或者线程死亡了，则返回false。
九、什么是死锁？
	   两个进程都在等待对方执行完毕才能继续往下执行的时候就会发生了死锁，结果就是两个惊醒，都陷入了无限等待中，
十、设计模式的分类
	设计模式的六大原则：开闭原则() 里氏代换原则() 依赖倒转原则() 接口隔离原则() 合成/聚合复用原则()
	总体来说设计模式分三大类：
	创建型模式：工厂方法模式  抽象工厂模式  单例模式  建造者模式  原型模式  
	结构型模式：适配器模式  装饰着模式  代理模式  外观模式  桥接模式  组合模式  享元模式
	行为型模式：策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 终结者模式 解释器模式
	常用的设计模式（单例模式 动态代理模式 工厂模式）
	(1)静态代理模式
		这种代理方式需要代理对象和目标对象实现一样的接口
		优点：可以在不修改目标对象的前提下扩展目标对象的功能。
		缺点：1.冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。
			  2.不易维护一旦接口增加方法，目标对象与代理对象都要进行修改。
	(1.1)动态代理模式
		动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能，动态代理又被称为JDK代理或接口代理
		静态代理与动态代理的区别：
			静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件。
	(2)单例模式
		1.单例类只能有一个实例，
		2.单例类必须自己创建自己唯一实例。
		3.单例类必须给所有其他对象提供这一实例
	(3)工厂模式
		意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
		主要解决：主要解决接口选择的问题。
		如何使用：我们明确地计划不同条件下创建不同地实例时，
		如何解决:让其子类实现工厂接口，返回的也是一个抽象的产品。
		关键代码：创建过程在其子类执行
	(4)装饰者模式
		意图：装饰着模式通过组合的方法扩展对象的特性，这种方式允许我们在任何时候对对象的功能进行扩展甚至是运行时扩展。
		主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承未类引入静态特征，并且随着扩展功能的增多，子类会很膨胀，
		如何使用：在不想增加很多子类的情况下扩展类，
		如何解决：将具体功能职责划分，同时继承者装饰者模式
		关键代码：1.Component 类充当抽象角色，不应该具体实现，2.修饰类引用和继承Component类，具体扩展类重写父类方法。
	   

mysql数据库  sql的编写  sql语句的优化
什么是mysql：
mySql是一种开放源码的关系型数据库管理系统(RDBMS)，使用最常用的数据库管理语言--结构化查询语言(SQL)进行数据库管理。
优点：
	mysql因为速度快，可靠性和适应性而备受关注，大多数人都认为在不需要事务化处理的情况下，mysql是管理内容最好的选择，
(索引)：1.概念：索引是对数据库中一或多个列值的排序，帮助数据库高效获取数据的数据结构。数据库中的索引就相当于书籍中的目录一样，当我们想找到
				书中莫个知识点，我们可以直接去目录找而不是在书中每页找，但是这也抛出了索引的一个知识点，在对数据库修改的时候要修改索引到导致时间变多。
		2.分类：普通索引  唯一索引  主键索引 全文索引
		3.优点：加快检索速度  唯一索引确保每行数据的唯一性  在使用索引的过程可以优化隐藏器，提高系统性能
		4.缺点：插入删除 修改 维护速度下降  占用物理和数据空间
(事务)：1.应用场景：存在并发数据访问时才修要事务
		2.事务的四大特性：
			1)原子性(Atomicity)：整个事务中所有的操作，要么全部完成，要么全部不完成，不可能停滞都在中间莫个环节，任何一项操作的失败都会导致整个事务的失败。
			2)一致性(Correspondence):在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
			3)隔离性(isolation):并发执行的事务彼此无法看到对方的中间状态。
			4)持久性(Durability):在事务完成之后，该事务所对数据库作的更改便持久的保存在数据库中，并不会被回滚
		3.事务中的问题与隔离级别
			问题：脏读：一个事务读取到另一个事务未提交的数据；
				  不可重复读：一个事务中两次查询的数据不一样  ---一个事务读取到了另一个事务  已经提交数据（update操作）
				  虚读(幻读)：一个事务中两次查询的数据不一致  ---一个事务读取到了另一个事务 已经提交数据（insert操作）
			隔离级别(安全从低到高 性能从高到低)
				读未提交：也叫脏读，是事务可以读取其他事务未提交的数据  ---为解决任何问题
				读已提交：在事务未提交之前所作的修改其他事务是不可见的  ---解决脏读问题
				可重复读：保证同一个事务中的多次相同的查询的结构是一致的  ---解决脏读、不可重复读问题
				可串行化：保证读取的范围内没有新的数据插入，比如事务第一次查询到得到莫个范围的数据，第二次查询也同样得到了相同范围的数据，
						  中间没有新的数据插入到该范围中   ---解决脏读，不可重复读，虚读（幻读）问题；
				常用的数据库默认隔离级别：
				mysql：可重复度
				oracle：读以提交2
				sqlserver:读以提交
		4.如何进行事务管理
			Connection 提供了事务处理的方式，通过调用setAutoCommit(false)可以处理设置手动提交事务，当事务完成后用commit()显示提交事务，如果在事务处理的过程中发生
			异常通过rollback()进行事务的回滚，除此之外，从jdbc3.0中还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚带是定的保存点。
sql的优化：
		为什么要优化：
			1.系统的吞吐量瓶颈往往出现在数据库的访问速度上
			2.随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应的慢
			3.数据是存放在磁盘上的，读写速度无法和内存相比
		如何优化：
			1.设计数据库时；数据库表、字段的设计、存储引擎
			2.利用好Mysql自身提供的功能，如索引等
			3.横向扩展：mysql集群、负载均衡、读写分离
			4.sql语句的优化(收效甚微)；
			
Redis mongoDB
1.什么是redis：redis是一个基于内存的高性能key--value数据库
	应用场景：会话缓存（session Cache）  全页缓存（FPC）  队列  排行榜/计数器   发布/订阅
2.使用redis有什么好处？
		1)速度快，因为数据存在内存中。类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是0。
		2)支持丰富数据类型，支持string list set  sorted set   hash
		3)支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
		4)丰富的特征；可用于缓存 消息 按key设置过期时间，过期后会自动删除
3.redis的特点：
		Redis本质上是一个key-value类型的内存数据库，很想memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据数据
		flush到硬盘上进行保存，因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的key-value DB;
		Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构。
4.为什么redis需要把所有数据放到内存中？
		Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，所以redis具有快速和数据持久化的特征。
lucene全文检索 
activeMQ 消息服务中间件
1.什么是activeMQ?
		ActiveMQ是apache出品，最流行的，能力强劲的开源消息总线，ActiveMQ是一个完全支持JMS1.1和J2EE1.4规范的JMS Provide实现，尽管JMS规范出台已经是很久的事情了，
		但是JMS在当今的J2EE应用中间任然扮演者特殊的地位。
	主要特点：
		1.多种语言和协议编写客户端，语言：Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP
		2.完全支持JMS1.1和J2EE 1.4规范(持久化，XA，消息，事务)
		3.对string的支持，ActiveMQ可以很容易内嵌到使用spring的系统里面去，而且也支持spring2.0的特性。
		4.通过常见J2EE服务器的测试，其中通过JCA 1.5resource asaptors的配置，可以让ActiveMQ可以自动地部署到任何兼容J2EE 1.4商业服务器上
		5.支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA
		6.支持通过JDBC和journal提供高速地消息持久化，
		7.从设计上保证了高性能地集群，客户端 服务器 点对点
		8.支持ajax   9.支持于Axis的整合   10.可以很容易的调用内嵌JMS proviedr 进行测试。
2.ActiveMQ的消息形式
		1)点对点：加一个生产者和一个消费者  对应
		2)发布/订阅：即一个生产者产生消息并进行发送后，可以由多个消费者进行接受。
		点对点模式：荣国消息发送不成功此，消息默认会保存到activeMQ服务端知道有消费者将其消费，所以此时消息是不会丢失的。
		发布订阅模式：默认情况下只通知一次，如果接受不到此消息就没有了，这种场景只适用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要
					  配置持久订阅，每个订阅端订阅一个id，在订阅是向activeMQ注册，发布消息和接收消息时需要配置发送模式为持久化，此时，如果客户端接收不到
					  消息，消息会持久化到客户端，知道客户端正常接收后为止。
3.ActiveMQ的作用、原理？
		activeMQ的作用就是系统之间进行通讯，当然可以使用其他的方式进行系统间通讯，如果使用activeMQ的话可以对系统之间的调用进行解耦，实现系统间的异步通信，
		原理就是生产者生产消息，把消息发送给activeMQ，activeMQ接收到消息然后查看有多少个消费者，然后把消息转发给消费者，此过程中生产者无需参与消费者接受
		到消息后做相应的处理和胜场者没有任何关系。
4.ActiveMQ在项目中应用场景？
		activemq在项目中主要时完成系统之间通信，并且将系统之间的调用进行解耦例如：在添加、修改商品信息后，需要将商品信息同步到索引库中，同步缓存中的数据以及生成
		静态页面一系列操作，在此场景下就可以使用activemq一旦后台对商品信息进行修改后，就向activeMQ发送一条信息，然后通过activeMQ将消息发送给消息的消费端，消费端
		接收到消息可以进行相应的业务处理。
5.activeMQ如果数据提交不成功怎么办？
		我们可以利用activeMQ的消息重发机制(RedeliveryPolicy)来解决这个问题。
freeMaker 模板引擎
		1.什么是freeMaker？
			freeMaker是一个用Java语言编写的模板引擎，他基于模板来生成文本输出，freeMaker与web容器无关，即在web运行时，他并不知道servlet或HTTP，它不仅可以用作变现层的实现技术
			而且还可以用于生成XML、JSP、JAVA 等；
		2.使用步骤：
			1)创建一个Cnfiguration对象，直接new一个对象，构造方法参数就是freemarker对于的版本号
			2)设置模板文件所在的路径
			3)设置模板文件所使用的字符集
			4)加载一个模板，创建一个模板对象
			5)创建一个一个模板使用的数据集，可以是pojo也可以是map，一般是Map
			6)创建一个Writer对象，一般创建FileWriter对象，指定生成的文件名。
			7)调用模板对象的process方法输出文件
			8)关闭流
jQuery 前端框架
1.什么是jQuery?
		jQuery是一套跨浏览器的JavaScript库，简化HTML与JavaScript之间的操作
ajax前端框架 
1.什么是ajax 
	Ajsx是一种创建交互式网页应用的网页开发技术(Asynchronous JavaScript and XML) AJAX技术基于Javascript和HTTP Request.
2.Ajaxde 优势
	1.通过异步模式，提升了用户体验
	2.优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
	3.ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大量用户下的服务器负载
3.ajax的最大特点：
	可以实现局部刷新，在不更新整个页面的前提下维护数据，提升用户体验度
	就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变过的信息。
	注意：ajax在实际项目开发中使用率分成高
4.ajax技术体系的组成部分有哪些？
	HTML CSS DOM XML xmlHttpRequest  javascript
angularJS前端框架 
1.什么是angularJS
	AngularJS是一款由Google维护的开源JavaScript库，用来协助单一页面应用程序运行。它的目标是透过MVC模式（MVC）功能增强基于浏览器的应用，使开发和测试变得更加容易。

bootstrap前端框架
1.什么是bootstrap？
	Bootstrap是一组用于网站和网络应用程序开发的开源前端（所谓“前端”，指的是展现给最终用户的界面。与之对应的“后端”是在服务器上面运行的代码）框架，包括HTML、CSS及JavaScript的框架
	提供字体排印、窗体、按钮、导航及其他各种组件及Javascript扩展，旨在使动态网页和Web应用的开发更加容易

Spring
1.spring的工作流程的理解
	1)创建配置文件applicationContext.xml
	2)编写配置文件(加入一些对象的配置信息)
	3)spring内部采用工厂模式，配合xml解析+反射技术，可以根据用户的配置生成相应的对象。
	4)工厂提供一个getbean方法，从工厂中获取对象
	5)操作对象的方法，属性
2.spring对象创建的三种方式
	1.无参构造2.实例工厂 3.静态工厂
3.不适用注解的情况下，如果给对象注入值的话，有哪几种方式？常用的是那些？
	1.set注值（重点）：set我们通过配置文件给对象(user)赋值，就相当于我们使用对象里边属性的set方法给对象设置值。
	2.构造器注值 3.p名称空间注值 4.spel注值 5.注入Java复杂类型 
	6.注入对象类型（重点）：使用ref变欧式注入一个已近存在的对象(默认调用的还是set方法注入)
4.spring的事物管理
	spring提供的事物管理可以分为两种：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的梗灵活。
	编程式 主要使用transactionTemplate,省略了部分的提交，回滚，一系列的事物对对象定义，需要注入事物管理对象，
	声明式 使用TransactionProxyFactoryBean 围绕poxy的动态代理，能够自动的提交和回滚事物。
5.soring 原理
	①IOC(inversion of control)：控制反转 依赖注入
	1)IOC:控制权由对象本身转向容器，由容器根据配置文件去创建实例并创建各个实例之间的依赖关系。
	2)依赖ioc容器负责管理bean，有两种 一种是BeanFactory，另一种是ApplicationContext 但是ApplicationContext继承与BeanFactory。
	核心：bean工厂、在spring中，bean工厂创建的各个实例称作bean
	②AOP(Aspect-Oriented Programming)：面向方面编程
	1)代理的两种方式：
		静态代理：针对每个具体类分别编写代理类  针对一个接口编写一个代理类
		动态代理：针对一个方面编写一个invocationHandler，然后借用JDK反射包中的proxy类为各种接口动态生成相应的代理类
	2)AOP的主要原理：动态代理实现： JDK Proxy和Cglib，spring规定对于有接口的类用JDK Proxy，对于无接口和抽象类用Cglib，虽然Cglib均可以代理，但是Cglib复杂
									效率低，但是Cglib有例外，就是代理的类中不能是final修饰的类或者类中有final方法。
6.使用spring又是什么好处？
	1)spring能有效的组织你的中间层对象，无论你是否选择使用了EJB，如果你仅仅使用了struts或其他的包含了J2EE特有APIs的framework，你会发现spring关注了遗留下的问题。
	2)spring能够消除在许多工程上对Singleton的过多使用，它减少了系统的可测试性和面向对象特征。
	3)spring能消除使用各种各样格式的属性定制文件的需要，在整个应用和过程中，可以通过一种一致的方法来进行配置。
	4)使用spring构建的应单元测试
SpringMVC
1.springMVC的执行流程是什么？
	1)用户发送请求至前端控制器
	2)前端控制器收到请求调用处理器映射器
	3)处理器映射器根据请求url找到具体的处理器，生成处理器执行链(包括处理器对象和处理器拦截器)一并返回给前端控制器
	4)前端控制器根据处理器Handler获取处理器适配器执行处理器适配器处理一系列的操作，如：参数的封装 数据格式的装换  数据的验证
	5)执行处理器 Handler(Controller，也叫页面控制器)
	6)Handler执行完成返回模型和视图
	7)处理器适配器将Handler执行结果模型和视图返回到前端控制器
	8)前端控制器将模型和视图传给视图解析器
	9)视图解析器解析后返回具体的视图
	10)前端控制器对视图进行渲染视图(即将模型数据mode填充至视图中)
	11)前端控制器响应用户
2.常用的springmvc注解有哪些？如何开启springmvc的注解扫描？
	@requestMapping  用于请求url映射
	@requestBoby 注解实现接收http请求的json数据，将json数据转换为Java对象，
	@responseBoby注解实现将controller方法返回对象转换为json响应给客户。
3.如何开启注解处理器和适配器的配置？
	在springmvc.xml中通过开启<mvc:annotatio-driven>来实现注解处理器和适配器的开启。
4.zaispringmvc框架的时候，如何解决post和get的乱码问题？
	解决post请求乱码：我们可以在web.xml里边配置一个CharacterEncodingFilter过滤器。设置为utf-8，
	解决get请求乱码：1.修改tomcat配置文件添加编码与工程编码一致。
					 2.另外一种方法对参数进行重新编码String userName=new String(Request.getParameter("userName").getBytes(ISO8859-1),"UTF-8");
	
Mybatis
1.什么是mybatis
	1)mybatis是一个优秀的基于Java的持久层框架，它内部封装了jdbc，是开发者只需要关注sql语句本身，而不需要发费精力去处理加载驱动、加载驱动、创建statement等繁杂的过程，
	2)mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中的sql的动态参数进行映射生成最终执行的sql语句。
	Springboot、Springdata、SpringCloud框架